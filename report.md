## Part 1. Ready-made docker
- Выкачиваем официальный докер-образ с nginx при помощи  `docker pull`
<br>![docker pull nginx](img/1-1.png)
- Проверяем наличие докер-образа через `docker images`
<br>![docker images](img/1-2.png)
- Запускаем докер-образ через `docker run -d [image_id|repository]`
<br>![docker run -d nginx](img/1-3.png)
- Проверяем, что образ запустился через `docker ps`
<br>![docker ps](img/1-4.png)
- Смотрим информацию о контейнере через `docker inspect [container_id|container_name]`
<br>![docker inspect 1](img/1-5-1.png)<br>
продолжение вывода `docker inspect`
<br>![docker inspect 2](img/1-5-2.png)<br>
продолжение вывода `docker inspect`
<br>![docker inspect 3](img/1-5-3.png)<br>
чтобы увидеть размер контейнера, выполним команду `docker inspect [container_id|container_name]` с флагом `-s` (то же самое, что `--size`)
<br>![docker inspect 4](img/1-5-4.png)
- По выводу команды определяем:
    - размер контейнера: 1095 байт
    - список замапленных портов: нет
    - ip контейнера: 172.17.0.2
<br><br>Размер контейнера также можно узнать при помощи команды `docker ps` с флагом `-s` 
<br>![docker ps -s](img/1-5-5.png)
- Останавливаем докер образ через `docker stop [container_id|container_name]`
<br>![docker stop](img/1-6.png)
- Проверяем, что образ остановился через `docker ps`, и видим, что нет работающих контейнеров
<br>![docker ps](img/1-7.png)
- Запускаем докер с портами _80_ и _443_ в контейнере, замапленными на такие же порты на локальной машине, через команду `run`
<br>![docker run  -d -p 80:80 -p 443:443 nginx](img/1-8.png)
- Проверяем, что в браузере по адресу _localhost:80_ доступна стартовая страница _nginx_
<br>![localhost:80](img/1-9.png)
- Перезапускаем докер контейнер через `docker restart [container_id|container_name]` и проверяем при помощи команды `docker ps`, что контейнер запустился 
<br>![docker restart 366ee945e23f](img/1-10.png) 

---

## Part 2. Operations with container
- Читаем конфигурационный файл _nginx.conf_ внутри докер контейнера через команду `exec`
<br>![docker exec](img/2-1.png)
- Создаём на локальной машине файл _nginx.conf_
<br>![touch nginx.conf](img/2-2.png)
- Настраиваем в нём по пути _/status_ отдачу страницы статуса сервера _nginx_
<br>![vim nginx.conf](img/2-3.png)
- Копируем созданный файл nginx.conf внутрь докер-образа через команду `docker cp`
<br>![docker cp](img/2-4.png)
- Перезапускаем _nginx_ внутри докер-образа через команду `exec`, предварительно проверив его
<br>![reload](img/2-5.png)
- Проверяем, что по адресу _localhost:80/status_ отдается страничка со статусом сервера _nginx_
<br>![localhost/status](img/2-6.png)
- Экспортируем контейнер в файл _container.tar_ через команду `export`
<br>![docker export](img/2-7.png)
- Останавливаем контейнер
<br>![docker stop](img/2-8.png)
- Удаляем образ через `docker rmi [image_id|repository]`, не удаляя перед этим контейнеры, для этого необходим флаг `-f`
<br>![docker rmi](img/2-9.png)
- Удаляем остановленный контейнер
<br>![docker rm](img/2-10.png)
- Импортируем контейнер обратно через команду `import`, видим что до импорта у нас нет ни образов, ни работающих контейнеров, а после импорта появился образ
<br>![docker import](img/2-11.png)
- Запускаем импортированный контейнер
<br>![docker run](img/2-12.png)
- Проверяем, что по адресу _localhost:80/status_ отдается страничка со статусом сервера _nginx_.
<br>![localhost:80/status](img/2-13.png)

---

## Part 3. Mini web server
- Напишем мини-сервер на _C_ и _FastCgi_, который будет возвращать простейшую страничку с надписью _Hello World!_ и сохраним его в файле _mini_server.c_
<br>![mini_server.c](img/3-1.png)
- Запускаем контейнер и обновляем в нём список доступного ПО, после чего мы можем установить в контейнере _gcc_ и библиотеку _fcgi_ (для компиляции исходного кода нашего мини-сервера), а также _spawn-fcgi_ (для запуска нашего мини-сервера)
<br>![docker run](img/3-2-1.png)
- Копируем файл _mini_server.c_ в контейнер, компилируем его и запускаем при помощи _spawn-fcgi_
<br>![docker cp](img/3-2-2.png)
- Пишем свой nginx.conf, который будет проксировать все запросы с _81_ порта на _127.0.0.1:8080_
<br>![nginx.conf](img/3-3.png)
- Копируем файл конфигурации _nginx_ в контейнер и перезагружаем _nginx_
<br>![docker cp](img/3-4-1.png)
- Проверяем, что в браузере по _localhost:81_ отдаётся написанная нами страничка
<br>![localhost:81](img/3-4-2.png)
Переносим файл _nginx.conf_ по пути _./nginx/nginx.conf_ (это понадобится позже)
<br>![mkdir && mv](img/3-5.png)

---

## Part 4. Your own docker
- Напишем свой докер-образ, воспользовавшись готовым образом с _nginx'ом_, как базовым, который:
1. собирает исходники нашего мини-сервера на _FastCgi_;
2. запускает его на _8080_ порту;
3. копирует внутрь образа написанный _./nginx/nginx.conf_;
4. запускает _nginx_.
<br>Dockerfile:
<br>![Dockerfile](img/4-1.png "Dockerfile")
- Проверяем через `docker images`, что образов на данный момент в _docker'е_ нет. Собираем написанный докер-образ через `docker build`, при этом указав имя и тег. Проверяем через `docker images`, что всё собралось корректно - образ появился. Запускаем собранный докер-образ с маппингом _81_ порта на _80_ на локальной машине и маппингом папки _./nginx_ внутрь контейнера по адресу, где лежат конфигурационные файлы _nginx'а_
<br>![docker build](img/4-2.png)
- Проверяем, что по _localhost:80_ доступна страничка написанного мини-сервера
<br>![localhost:80](img/4-3.png)
- Дописываем в _./nginx/nginx.conf_ проксирование странички _/status_, по которой надо отдавать статус сервера _nginx_, сохраняем файл
<br>![nginx/nginx.conf](img/4-4.png)
- Перезапускаем контейнер
<br>![nginx/nginx.conf](img/4-5.png)
- Конфигурационный файл внутри докер-образа обновился самостоятельно, без лишних действий. Убеждаемся в этом, проверив, что теперь по _localhost:80/status_ отдается страничка со статусом _nginx_
<br>![nginx/nginx.conf](img/4-6.png)

---

## Part 5. Dockle
- Просканируем наш образ через `dockle [image_id|repository]`
<br>![dockle](img/5-1.png)
- Исправим _Dockerfile_
<br>![Dockerfile](img/5-2.png)
- После пересборки образа при проверке через _dockle_ нет ошибок и предупреждений
<br>![Dockerfile](img/5-3.png)

---

## Part 6. Basic Docker Compose
- Напишем файл _docker-compose.yml_, с помощью которого:
1. Поднимем докер-контейнер из нашего Dockerfile (он будет работать в локальной сети, т.к. не использованы инструкции EXPOSE и маппинг портов на локальную машину).
2. Поднимем докер-контейнер с _nginx_.
<br>8080 порт второго контейнера замаплен на 80 порт локальной машины
<br>![docker-compose.yml](img/6-1.png)
- Проксирование всех запросов с _8080_ порта второго контейнера на _81_ порт первого контейнера настраивается в nginx.conf
<br>![nginx.conf](img/6-2.png)
- Проверяем, что все запущенные контейнеры остановлены. Собираем и запускаем проект с помощью команд `docker-compose build` и `docker-compose up`
<br>![docker ps](img/6-3.png)
- Проверяем, что в браузере по _localhost:80_ отдаётся наша страничка, как и ранее
<br>![docker ps](img/6-4.png)
